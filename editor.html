<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>æ¥¼ç›˜è§„åˆ’å›¾é…ç½®å™¨</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        :root {
            --top-pane-height: 40vh;   /* ä¸ŠåŠéƒ¨åˆ†ï¼ˆæ­¥éª¤1-4ï¼‰åˆå§‹é«˜åº¦ï¼Œå¯æ‹–åŠ¨å¤–å±‚åˆ†éš”æ¡è°ƒæ•´ */
            --table-height: 32vh;      /* ä¸‹åŠéƒ¨åˆ†å†…ï¼Œè¡¨æ ¼åˆå§‹é«˜åº¦ï¼Œå¯æ‹–åŠ¨å†…å±‚åˆ†éš”æ¡è°ƒæ•´ */
        }

        body { display: flex; margin: 0; height: 100vh; font-family: 'Microsoft YaHei', sans-serif; overflow: hidden; }

        /* å·¦ä¾§ç”»å¸ƒåŒº */
        #canvas-wrapper {
            flex: 1;
            background: #333;
            position: relative;
            overflow: hidden;
            cursor: grab;
        }
        #canvas-wrapper.grabbing { cursor: grabbing; }
        canvas {
            background: white;
            display: none;
            transform-origin: 0 0;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        #empty-tip {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #888; font-size: 18px; pointer-events: none;
        }
        #zoom-info {
            position: absolute; bottom: 10px; left: 10px;
            background: rgba(0,0,0,0.6); color: white;
            padding: 5px 10px; border-radius: 4px; font-size: 12px; pointer-events: none;
        }

        /* å³ä¾§è¾¹æ æ•´ä½“å¸ƒå±€ï¼šä¸Šä¸‹ä¸¤å—+ä¸¤ä¸ªåˆ†éš”æ¡ */
        #sidebar {
            width: 460px; background: #f8f9fa; border-left: 1px solid #ccc;
            padding: 16px; display: flex; flex-direction: column; z-index: 10;
            box-shadow: -2px 0 5px rgba(0,0,0,0.05);
            overflow: hidden;
            gap: 8px;
        }

        /* ä¸ŠåŠéƒ¨åˆ†ï¼ˆæ­¥éª¤1-4ï¼‰ */
        #topPane {
            height: var(--top-pane-height);
            min-height: 160px;
            overflow: auto;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            background: #ffffff;
            padding: 10px;
        }

        /* å¤–å±‚åˆ†éš”æ¡ï¼šè°ƒæ•´ topPane ä¸ bottomPane æ¯”ä¾‹ */
        .resizer {
            height: 8px;
            cursor: row-resize;
            border-radius: 6px;
            background: repeating-linear-gradient(
                90deg,
                #d7dee6 0, #d7dee6 6px,
                #e7edf3 6px, #e7edf3 12px
            );
            box-shadow: inset 0 0 0 1px #cfd6dd;
            user-select: none;
        }
        .resizer.active {
            background: #c7d7e7;
            box-shadow: inset 0 0 0 1px #9fb8d3;
        }

        /* ä¸‹åŠéƒ¨åˆ†ï¼ˆæ­¥éª¤5ï¼šè¡¨æ ¼åŒº + å†…å±‚åˆ†éš”æ¡ + å¯¼å‡ºæŒ‰é’®ï¼‰ */
        #bottomPane {
            flex: 1;
            min-height: 220px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        h3 { margin: 0 0 10px; color: #333; border-bottom: 2px solid #007bff; padding-bottom: 10px; }

        .step { margin-bottom: 14px; padding: 12px; background: #fff; border-radius: 6px; border: 1px solid #ddd; }
        .step.active { border-color: #007bff; box-shadow: 0 0 5px rgba(0,123,255,0.2); }
        label { display: block; margin-bottom: 6px; font-weight: bold; font-size: 13px; }
        input[type="text"], input[type="number"], input[type="file"] {
            width: 100%; box-sizing: border-box; padding: 8px; margin-bottom: 8px; border: 1px solid #ccc; border-radius: 4px; font-size: 14px;
        }
        .inline-inputs { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; }
        .inline-inputs .field { display: flex; flex-direction: column; }
        .inline-row { display: flex; align-items: center; gap: 8px; margin-top: 6px; }
        .inline-row input[type="checkbox"] { transform: scale(1.1); }

        button {
            width: 100%; padding: 10px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; margin-bottom: 6px; font-size: 14px;
        }
        button:hover { background: #0069d9; }
        button.secondary { background: #6c757d; }
        button.secondary:hover { background: #5a6268; }
        button.info { background: #17a2b8; }
        button.info:hover { background: #138496; }
        button.success { background: #28a745; }
        button.success:hover { background: #218838; }
        button.warning { background: #ffc107; color: #333; }
        button.warning:hover { background: #e0a800; }
        button:disabled { background: #ccc; cursor: not-allowed; }

        /* å†…å±‚è¡¨æ ¼å®¹å™¨ä¸åˆ†éš”æ¡ */
        #step-table { margin: 0; padding: 12px; border: 1px solid #ddd; border-radius: 6px; background: #fff; }
        #tableResizer { margin: 4px 0; }
        #table-wrapper {
            height: var(--table-height);
            min-height: 120px;
            overflow: auto;
            border: 1px solid #eee; border-radius: 6px; background: #fff;
        }
        table { width: 100%; border-collapse: collapse; font-size: 12px; }
        thead th { position: sticky; top: 0; background: #f1f3f5; z-index: 1; }
        th, td { border-bottom: 1px solid #eee; padding: 6px; text-align: left; }
        td input { width: 100%; padding: 6px; box-sizing: border-box; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; }
        td .center { color: #555; font-family: Consolas, Menlo, monospace; }
        td .btn-mini { display: inline-block; padding: 4px 8px; font-size: 12px; border-radius: 4px; border: none; cursor: pointer; }
        .btn-danger { background: #dc3545; color: #fff; }
        .btn-danger:hover { background: #c82333; }
        .btn-outline { background: transparent; color: #007bff; border: 1px solid #80bdff; }
        .btn-outline:hover { background: #e7f1ff; }

        /* å°å±è‡ªé€‚åº”ï¼šä¾§è¾¹æ å˜ä¸ºåº•éƒ¨æŠ½å±‰ */
        @media (max-width: 768px) {
            #sidebar { width: 100vw; position: absolute; right: 0; left: 0; bottom: 0; max-height: 60vh; overflow: hidden; }
            #topPane { max-height: 55vh; }
            #table-wrapper { max-height: 55vh; }
        }
    </style>
</head>
<body>

<div id="canvas-wrapper">
    <div id="empty-tip">è¯·åœ¨å³ä¾§ä¸Šä¼ å›¾ç‰‡å¼€å§‹è§„åˆ’</div>
    <canvas id="editorCanvas"></canvas>
    <div id="zoom-info">ç¼©æ”¾: 0%</div>
</div>

<div id="sidebar">
    <h3>ğŸ› ï¸ æ¥¼ç›˜æ•°æ®é…ç½®</h3>

    <!-- ä¸ŠåŠéƒ¨åˆ†ï¼ˆæ­¥éª¤1-4ï¼‰ï¼Œå¯æ•´ä½“æ»šåŠ¨ -->
    <div id="topPane">
        <div class="step" id="step-upload">
            <label>1. ä¸Šä¼ è§„åˆ’å›¾/æ€»å¹³å›¾</label>
            <input type="file" id="fileInput" accept="image/*">
            <div class="muted">æ”¯æŒæ‹–æ‹½ã€ç¼©æ”¾ã€ç»˜åˆ¶å¤šè¾¹å½¢è¡¨ç¤ºæ¥¼æ ‹è½®å»“ã€‚</div>
        </div>

        <div class="step" id="step-scale">
            <label>2. æ ‡å®šæ¯”ä¾‹å°º</label>
            <div class="muted" style="margin-bottom:5px;">
                çŠ¶æ€: <span id="scaleStatus">æœªæ ‡å®š</span>
            </div>
            <button id="btnStartScale" disabled>å¼€å§‹æ ‡å®š (ç‚¹å‡»ä¸¤ç‚¹)</button>
            <div id="scaleInputArea" style="display:none; margin-top:5px;">
                <label>ä¸¤ç‚¹é—´å®é™…è·ç¦» (ç±³):</label>
                <input type="number" id="realDistance" value="50" step="0.01" min="0">
                <button id="btnConfirmScale" class="secondary">ç¡®è®¤æ¯”ä¾‹</button>
            </div>
        </div>

        <div class="step active" id="step-draw">
            <label>3. ç»˜åˆ¶æ¥¼æ ‹</label>
            <div class="muted" style="margin-bottom:5px;">
                <span style="color:#28a745;">ğŸ–±ï¸ æ»šè½®ç¼©æ”¾ï¼ŒæŒ‰ä½ä¸­é”®æˆ–ç©ºæ ¼æ‹–æ‹½è§†å›¾</span><br>
                æ“ä½œ: å·¦é”®åŠ ç‚¹ï¼Œå·¦é”®åŒå‡»ç»“æŸï¼›å³é”®æ’¤é”€ä¸Šä¸ªç‚¹ã€‚
            </div>
            <button id="btnDrawMode" class="secondary">å½“å‰: âœ‹ æµè§ˆæ¨¡å¼</button>
            <button id="btnResetView" class="info" style="margin-top:5px;">âŸ² é‡ç½®è§†è§’</button>
        </div>

        <div class="step" id="step-defaults">
            <label>4. å…¨å±€é»˜è®¤å‚æ•°</label>
            <div class="inline-inputs">
                <div class="field">
                    <span class="muted">é»˜è®¤å±‚æ•°</span>
                    <input type="number" id="defFloors" value="18" min="1" step="1">
                </div>
                <div class="field">
                    <span class="muted">é»˜è®¤å±‚é«˜(ç±³)</span>
                    <input type="number" id="defFloorHeight" value="3" min="1" step="0.01">
                </div>
                <div class="field">
                    <span class="muted">é»˜è®¤æˆ·æ•°/å±‚</span>
                    <input type="number" id="defUnits" value="2" min="1" step="1">
                </div>
            </div>
            <div class="inline-row">
                <label style="margin:0; font-weight:normal;">
                    <input type="checkbox" id="defIsThisCommunity" checked> é»˜è®¤æ ‡è®°ä¸ºæœ¬å°åŒº
                </label>
            </div>
            <div class="inline-row">
                <label style="margin:0; font-weight:normal;">
                    <input type="checkbox" id="chkUseDefaults" checked> æ–°æ¥¼æ ‹ä½¿ç”¨é»˜è®¤å€¼
                </label>
                <button id="btnApplyDefaultsAll" class="btn-outline" style="width:auto;">åº”ç”¨åˆ°æ‰€æœ‰æ¥¼æ ‹</button>
            </div>
        </div>
    </div>

    <!-- å¤–å±‚åˆ†éš”æ¡ï¼šæ§åˆ¶ä¸Š(æ­¥éª¤1-4)ä¸ä¸‹(æ­¥éª¤5)çš„é«˜åº¦æ¯”ä¾‹ -->
    <div class="resizer" id="outerResizer" title="æ‹–åŠ¨ä»¥è°ƒæ•´ä¸Šæ–¹æ­¥éª¤åŒºä¸ä¸‹æ–¹è¡¨æ ¼åŒºçš„é«˜åº¦"></div>

    <!-- ä¸‹åŠéƒ¨åˆ†ï¼ˆæ­¥éª¤5 + å†…å±‚åˆ†éš”æ¡ + è¡¨æ ¼ï¼‰ -->
    <div id="bottomPane">
        <div class="step" id="step-table" style="margin:0;">
            <label>5. æ¥¼æ ‹å‚æ•°è¡¨ï¼ˆç»Ÿä¸€å¡«å†™/ç¼–è¾‘ï¼‰</label>
        </div>

        <!-- å†…å±‚åˆ†éš”æ¡ï¼šè°ƒæ•´è¡¨æ ¼é«˜åº¦ -->
        <div class="resizer" id="tableResizer" title="æ‹–åŠ¨ä»¥è°ƒæ•´ä¸‹æ–¹è¡¨æ ¼é«˜åº¦"></div>

        <div id="table-wrapper">
            <table>
                <thead>
                    <tr>
                        <th style="width:200px;">åç§°ï¼ˆå¯ç¼–è¾‘ï¼‰</th>
                        <th style="width:90px;">å±‚æ•°</th>
                        <th style="width:110px;">å±‚é«˜(ç±³)</th>
                        <th style="width:90px;">æˆ·/å±‚</th>
                        <th style="width:84px;">æœ¬å°åŒº</th>
                        <th style="width:80px;">æ“ä½œ</th>
                    </tr>
                </thead>
                <tbody id="tableBody">
                    <!-- åŠ¨æ€è¡Œ -->
                </tbody>
            </table>
        </div>

        <button id="btnExport" class="success" style="margin-top: 0;">å¯¼å‡º JSON é…ç½®</button>
    </div>
</div>

<script>
    const wrapper = document.getElementById('canvas-wrapper');
    const canvas = document.getElementById('editorCanvas');
    const ctx = canvas.getContext('2d');
    const fileInput = document.getElementById('fileInput');
    const zoomInfo = document.getElementById('zoom-info');
    const emptyTip = document.getElementById('empty-tip');

    // é»˜è®¤å‚æ•°å…ƒç´ 
    const defFloorsEl = document.getElementById('defFloors');
    const defFloorHeightEl = document.getElementById('defFloorHeight');
    const defUnitsEl = document.getElementById('defUnits');
    const defIsThisCommunityEl = document.getElementById('defIsThisCommunity');
    const btnApplyDefaultsAll = document.getElementById('btnApplyDefaultsAll');
    const chkUseDefaults = document.getElementById('chkUseDefaults');

    // æ ¸å¿ƒæ•°æ®
    let image = new Image();
    let isImageLoaded = false;
    let scaleRatio = 0; // 1åƒç´  = å¤šå°‘ç±³
    // {id,name,floors,floorHeight,units,isThisCommunity,points:[]}
    let buildings = [];

    // è§†å›¾çŠ¶æ€
    let viewScale = 1.0;
    let viewX = 0;
    let viewY = 0;

    // äº¤äº’æ¨¡å¼
    let mode = 'idle'; // 'idle', 'scaling', 'drawing'

    // ä¸´æ—¶æ•°æ®
    let scalePoints = [];
    let currentPoly = [];
    let mousePos = {x:0, y:0};

    // è§†å›¾æ‹–æ‹½
    let isDragging = false;
    let lastMouseX = 0;
    let lastMouseY = 0;

    // å¸é™„/é—­åˆ
    const CLOSE_EPS_BASE = 8;
    function dist(a, b) { return Math.hypot(a.x - b.x, a.y - b.y); }
    function pointsEqual(a, b, eps = 0) {
        if (!a || !b) return false;
        if (eps > 0) return dist(a, b) <= eps;
        return a.x === b.x && a.y === b.y;
    }

    // ========== æ–°å¢ï¼šå¤šè¾¹å½¢å‡€åŒ– ==========
    // å»æ‰æœ«å°¾é‡å¤é¦–ç‚¹ã€ç›¸é‚»è¿‘é‡å¤ç‚¹ã€è¿‘ä¼¼å…±çº¿ç‚¹ã€æçŸ­è¾¹
    function sanitizePolygon(rawPoints, epsPx = 0.5) {
        if (!Array.isArray(rawPoints)) return [];
        const eps = Math.max(1e-6, epsPx);

        // 0) æ‹·è´åå»æ‰é¦–å°¾é‡å¤
        let pts = rawPoints.slice();
        if (pts.length >= 2 && pointsEqual(pts[0], pts[pts.length - 1], eps)) {
            pts.pop();
        }
        if (pts.length < 3) return pts;

        // 1) å»ç›¸é‚»è¿‘é‡å¤ç‚¹
        const dedup = [];
        for (let i = 0; i < pts.length; i++) {
            const p = pts[i];
            const q = dedup[dedup.length - 1];
            if (!q || !pointsEqual(p, q, eps)) dedup.push({ x: p.x, y: p.y });
        }
        if (dedup.length >= 2 && pointsEqual(dedup[0], dedup[dedup.length - 1], eps)) dedup.pop();
        if (dedup.length < 3) return dedup;

        // 2) å»æçŸ­è¾¹
        const shortThresh = eps;
        let clean = dedup.slice();
        let changed = true;
        function edgeLen(i, j) { return dist(clean[i], clean[j]); }
        function mod(n, m) { return ((n % m) + m) % m; }

        while (changed && clean.length > 3) {
            changed = false;
            for (let i = 0; i < clean.length; i++) {
                const j = mod(i + 1, clean.length);
                if (edgeLen(i, j) < shortThresh) {
                    clean.splice(j, 1);
                    changed = true;
                    if (clean.length <= 3) break;
                }
            }
        }
        if (clean.length < 3) return clean;

        // 3) å»è¿‘ä¼¼å…±çº¿ç‚¹
        const result = [];
        const n = clean.length;
        for (let i = 0; i < n; i++) {
            const p0 = clean[mod(i - 1, n)];
            const p1 = clean[i];
            const p2 = clean[mod(i + 1, n)];
            const v1x = p1.x - p0.x, v1y = p1.y - p0.y;
            const v2x = p2.x - p1.x, v2y = p2.y - p1.y;
            const cross = Math.abs(v1x * v2y - v1y * v2x);
            const len1 = Math.hypot(v1x, v1y);
            const len2 = Math.hypot(v2x, v2y);
            if (cross > eps * (len1 + len2)) result.push(p1);
        }
        if (result.length < 3) return clean;

        return result;
    }

    // å›¾ç‰‡åŠ è½½
    fileInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if(!file) return;
        const reader = new FileReader();
        reader.onload = (event) => {
            image.onload = () => {
                canvas.style.display = 'block';
                emptyTip.style.display = 'none';

                canvas.width = image.width;
                canvas.height = image.height;
                isImageLoaded = true;
                document.getElementById('btnStartScale').disabled = false;
                resetView();
                draw();
            };
            image.src = event.target.result;
        };
        reader.readAsDataURL(file);
    });

    // é‡ç½®è§†å›¾
    function resetView() {
        if(!isImageLoaded) return;
        const padding = 40;
        const wRatio = (wrapper.clientWidth - padding) / canvas.width;
        const hRatio = (wrapper.clientHeight - padding) / canvas.height;
        viewScale = Math.min(wRatio, hRatio, 1);
        viewX = (wrapper.clientWidth - canvas.width * viewScale) / 2;
        viewY = (wrapper.clientHeight - canvas.height * viewScale) / 2;
        updateTransform();
    }
    document.getElementById('btnResetView').addEventListener('click', resetView);

    function updateTransform() {
        canvas.style.transform = `translate(${viewX}px, ${viewY}px) scale(${viewScale})`;
        zoomInfo.innerText = `ç¼©æ”¾: ${Math.round(viewScale * 100)}%`;
    }

    // åæ ‡æ¢ç®—
    function getCanvasCoordinates(e) {
        const rect = wrapper.getBoundingClientRect();
        const mouseXInWrapper = e.clientX - rect.left;
        const mouseYInWrapper = e.clientY - rect.top;
        const canvasX = (mouseXInWrapper - viewX) / viewScale;
        const canvasY = (mouseYInWrapper - viewY) / viewScale;
        return { x: canvasX, y: canvasY };
    }

    // æ»šè½®ç¼©æ”¾
    wrapper.addEventListener('wheel', (e) => {
        if(!isImageLoaded) return;
        e.preventDefault();

        const zoomSpeed = 0.1;
        const delta = e.deltaY > 0 ? (1 - zoomSpeed) : (1 + zoomSpeed);
        const newScale = Math.min(Math.max(viewScale * delta, 0.1), 10);

        const rect = wrapper.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        const canvasOffsetX = (mouseX - viewX);
        const canvasOffsetY = (mouseY - viewY);

        viewX = mouseX - (canvasOffsetX * (newScale / viewScale));
        viewY = mouseY - (canvasOffsetY * (newScale / viewScale));

        viewScale = newScale;
        updateTransform();
    }, { passive: false });

    // é¼ æ ‡æŒ‰ä¸‹ï¼šæ‹–æ‹½è§†å›¾ã€åŠ ç‚¹ã€æ’¤é”€
    wrapper.addEventListener('mousedown', (e) => {
        if(!isImageLoaded) return;

        const isSpacePressed = e.getModifierState && e.getModifierState(" ");

        // è§†å›¾æ‹–æ‹½ï¼šä¸­é”®ï¼Œæˆ–ç©ºæ ¼+å·¦é”®ï¼Œæˆ–åœ¨æµè§ˆæ¨¡å¼ä¸‹å·¦é”®
        if (e.button === 1 || (mode === 'idle' && e.button === 0) || (isSpacePressed && e.button === 0)) {
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            wrapper.classList.add('grabbing');
            e.preventDefault();
            return;
        }

        // å·¦é”®åŠ ç‚¹
        if (e.button === 0) {
            const p = getCanvasCoordinates(e);
            if (mode === 'scaling') {
                scalePoints.push(p);
                if (scalePoints.length === 2) {
                    mode = 'idle';
                    updateCursor();
                    document.getElementById('scaleInputArea').style.display = 'block';
                }
                draw();
            } else if (mode === 'drawing') {
                currentPoly.push(p);
                draw();
            }
        }

        // å³é”®æ’¤é”€ä¸Šä¸ªç‚¹
        if (e.button === 2) {
            if (mode === 'drawing' && currentPoly.length > 0) {
                currentPoly.pop();
                draw();
            }
        }
    });

    // å·¦é”®åŒå‡»ç»“æŸé—­åˆ
    wrapper.addEventListener('dblclick', (e) => {
        if (!isImageLoaded) return;
        if (mode === 'drawing' && e.button === 0) {
            if (currentPoly.length >= 3) {
                finishPolygon();
            }
        }
    });

    window.addEventListener('mousemove', (e) => {
        if (isDragging) {
            const dx = e.clientX - lastMouseX;
            const dy = e.clientY - lastMouseY;
            viewX += dx;
            viewY += dy;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            updateTransform();
            return;
        }

        if(!isImageLoaded) return;
        mousePos = getCanvasCoordinates(e);
        if (mode === 'drawing') draw();
    });

    window.addEventListener('mouseup', () => {
        isDragging = false;
        wrapper.classList.remove('grabbing');
    });

    // é˜²æ­¢å³é”®èœå•å¹²æ‰°æ’¤é”€
    canvas.addEventListener('contextmenu', e => e.preventDefault());

    // æ¸²æŸ“
    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (!isImageLoaded) return;

        ctx.drawImage(image, 0, 0);

        // å·²ä¿å­˜æ¥¼æ ‹
        buildings.forEach(b => {
            drawPolygon(b.points, 'rgba(0, 123, 255, 0.28)', '#007bff');
            const center = getPolygonCenter(b.points);
            ctx.fillStyle = "white";
            ctx.font = `bold 16px Arial`;
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 3;
            ctx.strokeText(b.name, center.x - 10, center.y);
            ctx.fillText(b.name, center.x - 10, center.y);
        });

        // æ ‡å®šæ˜¾ç¤º
        if (scalePoints.length > 0) drawPoint(scalePoints[0], 'red');
        if (scalePoints.length === 2) {
            drawPoint(scalePoints[1], 'red');
            ctx.beginPath();
            ctx.moveTo(scalePoints[0].x, scalePoints[0].y);
            ctx.lineTo(scalePoints[1].x, scalePoints[1].y);
            ctx.strokeStyle = 'red';
            ctx.lineWidth = 2 / viewScale;
            ctx.stroke();
        }

        // å½“å‰ç»˜åˆ¶
        if (currentPoly.length > 0) {
            const first = currentPoly[0];
            const eps = CLOSE_EPS_BASE / viewScale;
            const nearStart = dist(mousePos, first) <= eps && currentPoly.length > 2;

            ctx.beginPath();
            ctx.moveTo(currentPoly[0].x, currentPoly[0].y);
            for (let i = 1; i < currentPoly.length; i++) {
                ctx.lineTo(currentPoly[i].x, currentPoly[i].y);
            }
            ctx.lineTo(mousePos.x, mousePos.y);
            ctx.strokeStyle = '#28a745';
            ctx.lineWidth = 2 / viewScale;
            ctx.stroke();

            // ç‚¹ä½
            currentPoly.forEach((p, idx) => drawPoint(p, idx === 0 ? '#ff9800' : '#28a745'));
            if (nearStart) {
                ctx.beginPath();
                ctx.arc(first.x, first.y, 10 / viewScale, 0, Math.PI * 2);
                ctx.strokeStyle = '#ff9800';
                ctx.lineWidth = 2 / viewScale;
                ctx.stroke();
            }
        }
    }

    function drawPoint(p, color) {
        ctx.beginPath();
        ctx.arc(p.x, p.y, 4 / viewScale, 0, Math.PI*2);
        ctx.fillStyle = color;
        ctx.fill();
    }

    function drawPolygon(points, fillColor, strokeColor) {
        if(points.length < 3) return;
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        for(let i=1; i<points.length; i++) ctx.lineTo(points[i].x, points[i].y);
        ctx.closePath();
        ctx.fillStyle = fillColor;
        ctx.fill();
        ctx.strokeStyle = strokeColor;
        ctx.lineWidth = 2 / viewScale;
        ctx.stroke();
    }

    function getPolygonCenter(points) {
        let x = 0, y = 0;
        points.forEach(p => { x += p.x; y += p.y; });
        return { x: x / points.length, y: y / points.length };
    }

    function finishPolygon() {
        if (scaleRatio === 0) {
            alert("è¯·å…ˆæ ‡å®šæ¯”ä¾‹å°ºï¼");
            currentPoly = [];
            draw();
            return;
        }
        if (currentPoly.length < 3) {
            alert("è‡³å°‘éœ€è¦ä¸‰ä¸ªç‚¹æ‰èƒ½é—­åˆæ¥¼æ ‹ã€‚");
            currentPoly = [];
            draw();
            return;
        }

        const eps = 0.75;
        const cleaned = sanitizePolygon(currentPoly, eps);
        if (cleaned.length < 3) {
            alert("ç»˜åˆ¶çš„å¤šè¾¹å½¢æ— æ•ˆï¼Œè¯·é‡ç”»ã€‚");
            currentPoly = [];
            draw();
            return;
        }

        const idx = buildings.length + 1;
        const useDefaults = chkUseDefaults.checked;
        const b = {
            id: Date.now() + Math.random(),
            name: `${idx}å·æ¥¼`,
            floors: useDefaults ? clampInt(parseInt(defFloorsEl.value), 1, 300, 18) : 18,
            floorHeight: useDefaults ? clampNum(parseFloat(defFloorHeightEl.value), 1, 20, 3) : 3,
            units: useDefaults ? clampInt(parseInt(defUnitsEl.value), 1, 20, 2) : 2,
            isThisCommunity: useDefaults ? !!defIsThisCommunityEl.checked : true,
            points: cleaned
        };
        buildings.push(b);
        currentPoly = [];
        renderTable();
        draw();
    }

    // æ ‡å®š
    document.getElementById('btnStartScale').addEventListener('click', () => {
        scalePoints = [];
        mode = 'scaling';
        updateCursor();
        document.getElementById('scaleStatus').innerText = "è¯·åœ¨å›¾ä¸­ç‚¹å‡»ä¸¤ç‚¹";
        document.getElementById('scaleInputArea').style.display = 'none';
        draw();
    });

    document.getElementById('btnConfirmScale').addEventListener('click', () => {
        if (scalePoints.length < 2) {
            alert("è¯·å…ˆåœ¨å›¾ä¸Šé€‰æ‹©ä¸¤ç‚¹ã€‚");
            return;
        }
        const distPx = Math.hypot(scalePoints[1].x - scalePoints[0].x, scalePoints[1].y - scalePoints[0].y);
        const distReal = parseFloat(document.getElementById('realDistance').value);
        if (!(distReal > 0) || !(distPx > 0)) {
            alert("è¯·è¾“å…¥æ­£ç¡®çš„å®é™…è·ç¦»ï¼Œå¹¶ç¡®ä¿ä¸¤ç‚¹ä¸é‡åˆã€‚");
            return;
        }
        scaleRatio = distReal / distPx;
        document.getElementById('scaleStatus').innerText = `å·²æ ‡å®š (1px â‰ˆ ${scaleRatio.toFixed(4)}m)`;
        document.getElementById('scaleInputArea').style.display = 'none';
        toggleDrawMode(true);
        renderTable(); // ä¿ç•™ï¼ˆå°½ç®¡è¡¨æ ¼æ— ä¸­å¿ƒç‚¹åˆ—ï¼‰
    });

    // ç»˜åˆ¶æ¨¡å¼åˆ‡æ¢
    const btnDrawMode = document.getElementById('btnDrawMode');
    btnDrawMode.addEventListener('click', () => {
        toggleDrawMode(mode !== 'drawing');
    });

    function toggleDrawMode(active) {
        if (active) {
            mode = 'drawing';
            btnDrawMode.innerText = "å½“å‰: âœï¸ æ­£åœ¨ç»˜åˆ¶ (åŒå‡»ç»“æŸ / å³é”®æ’¤é”€)";
            btnDrawMode.style.background = "#28a745";
            btnDrawMode.style.color = "white";
        } else {
            mode = 'idle';
            btnDrawMode.innerText = "å½“å‰: âœ‹ æµè§ˆæ¨¡å¼";
            btnDrawMode.style.background = "#6c757d";
            btnDrawMode.style.color = "white";
            currentPoly = [];
            draw();
        }
        updateCursor();
    }

    function updateCursor() {
        if (mode === 'drawing' || mode === 'scaling') {
            wrapper.style.cursor = 'crosshair';
        } else {
            wrapper.style.cursor = 'grab';
        }
    }

    // è¡¨æ ¼æ¸²æŸ“
    const tableBody = document.getElementById('tableBody');

    function renderTable() {
        tableBody.innerHTML = '';
        buildings.forEach((b, i) => {
            const tr = document.createElement('tr');

            // åç§°
            const tdName = document.createElement('td');
            const inpName = document.createElement('input');
            inpName.type = 'text';
            inpName.value = b.name;
            inpName.placeholder = 'è¾“å…¥åç§°ï¼ˆå¦‚ï¼š1å·æ¥¼/é…å»º/å¹¼å„¿å›­ï¼‰';
            inpName.addEventListener('input', () => {
                b.name = inpName.value || `${i+1}å·æ¥¼`;
                draw(); // ç”»å¸ƒæ ‡ç­¾å®æ—¶æ›´æ–°
            });
            tdName.appendChild(inpName);

            // å±‚æ•°
            const tdFloors = document.createElement('td');
            const inpFloors = document.createElement('input');
            inpFloors.type = 'number';
            inpFloors.min = 1; inpFloors.step = 1;
            inpFloors.value = b.floors;
            inpFloors.addEventListener('change', () => {
                b.floors = clampInt(parseInt(inpFloors.value), 1, 300, b.floors);
                inpFloors.value = b.floors;
            });
            tdFloors.appendChild(inpFloors);

            // å±‚é«˜
            const tdFloorH = document.createElement('td');
            const inpFloorH = document.createElement('input');
            inpFloorH.type = 'number';
            inpFloorH.min = 1; inpFloorH.step = 0.01;
            inpFloorH.value = b.floorHeight;
            inpFloorH.addEventListener('change', () => {
                b.floorHeight = clampNum(parseFloat(inpFloorH.value), 1, 20, b.floorHeight);
                inpFloorH.value = b.floorHeight;
            });
            tdFloorH.appendChild(inpFloorH);

            // æˆ·/å±‚
            const tdUnits = document.createElement('td');
            const inpUnits = document.createElement('input');
            inpUnits.type = 'number';
            inpUnits.min = 1; inpUnits.step = 1;
            inpUnits.value = b.units;
            inpUnits.addEventListener('change', () => {
                b.units = clampInt(parseInt(inpUnits.value), 1, 50, b.units);
                inpUnits.value = b.units;
            });
            tdUnits.appendChild(inpUnits);

            // æœ¬å°åŒºï¼ˆisThisCommunityï¼‰
            const tdOwn = document.createElement('td');
            const chkOwn = document.createElement('input');
            chkOwn.type = 'checkbox';
            chkOwn.checked = b.isThisCommunity !== false; // ç¼ºçœè§†ä¸º true
            chkOwn.addEventListener('change', () => {
                b.isThisCommunity = !!chkOwn.checked;
            });
            tdOwn.style.textAlign = 'center';
            tdOwn.appendChild(chkOwn);

            // æ“ä½œ
            const tdOps = document.createElement('td');
            const btnDel = document.createElement('button');
            btnDel.className = 'btn-mini btn-danger';
            btnDel.textContent = 'åˆ é™¤';
            btnDel.addEventListener('click', () => {
                if (confirm('ç¡®å®šåˆ é™¤è¯¥æ¥¼æ ‹å—ï¼Ÿ')) {
                    buildings.splice(i, 1);
                    renderTable();
                    draw();
                }
            });
            tdOps.appendChild(btnDel);

            tr.appendChild(tdName);
            tr.appendChild(tdFloors);
            tr.appendChild(tdFloorH);
            tr.appendChild(tdUnits);
            tr.appendChild(tdOwn);
            tr.appendChild(tdOps);

            tableBody.appendChild(tr);
        });
    }

    // åº”ç”¨é»˜è®¤å€¼åˆ°æ‰€æœ‰æ¥¼æ ‹
    btnApplyDefaultsAll.addEventListener('click', () => {
        const f = clampInt(parseInt(defFloorsEl.value), 1, 300, 18);
        const h = clampNum(parseFloat(defFloorHeightEl.value), 1, 20, 3);
        const u = clampInt(parseInt(defUnitsEl.value), 1, 50, 2);
        const own = !!defIsThisCommunityEl.checked;
        buildings = buildings.map(b => ({ ...b, floors: f, floorHeight: h, units: u, isThisCommunity: own }));
        renderTable();
        draw();
    });

    // å¯¼å‡º
    document.getElementById('btnExport').addEventListener('click', () => {
        if (buildings.length === 0) {
            alert("æ²¡æœ‰æ•°æ®å¯å¯¼å‡º");
            return;
        }

        // åŒä¿é™©ï¼šå¯¼å‡ºå‰å†æ¬¡å‡€åŒ–æ¯ä¸ªå¤šè¾¹å½¢ï¼ˆä¸å¼ºåˆ¶æŠŠé¦–ç‚¹åŠ åˆ°æœ«å°¾ï¼‰
        buildings = buildings.map(b => {
            const eps = 0.75;
            const cleaned = sanitizePolygon(b.points, eps);
            return { ...b, points: cleaned };
        });

        // è®¡ç®—æ•´ä½“ä¸­å¿ƒä½œä¸ºå¯¼å‡ºåŸç‚¹ï¼ˆåƒç´ åæ ‡ç³»ï¼‰
        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        buildings.forEach(b => {
            b.points.forEach(p => {
                if (p.x < minX) minX = p.x;
                if (p.x > maxX) maxX = p.x;
                if (p.y < minY) minY = p.y;
                if (p.y > maxY) maxY = p.y;
            });
        });
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;

        // å°æ•°ç‚¹åä¸¤ä½
        const round2 = n => Math.round(n * 100) / 100;

        const exportData = {
            version: 1.5,
            scaleRatio: scaleRatio,
            origin: { x: centerX, y: centerY }, // åŸç‚¹ä¿ç•™ä¸ºåƒç´ ï¼ŒæŒ‰åŸé€»è¾‘
            buildings: buildings.map(b => {
                const c = getPolygonCenter(b.points);
                const cx = (c.x - centerX) * scaleRatio;
                const cy = (c.y - centerY) * scaleRatio;

                return {
                    name: b.name,
                    floors: b.floors,
                    floorHeight: b.floorHeight,
                    units: b.units,
                    totalHeight: b.floors * b.floorHeight,
                    isThisCommunity: b.isThisCommunity !== false, // ç¼ºçœ true
                    // åæ ‡ï¼ˆç±³ï¼‰ä¿ç•™ä¸¤ä½å°æ•°
                    shape: b.points.map(p => ({
                        x: round2((p.x - centerX) * scaleRatio),
                        y: round2((p.y - centerY) * scaleRatio)
                    })),
                    center: { x: round2(cx), y: round2(cy) }
                };
            })
        };

        const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(exportData, null, 2));
        const downloadAnchorNode = document.createElement('a');
        downloadAnchorNode.setAttribute("href", dataStr);
        downloadAnchorNode.setAttribute("download", "buildings_config.json");
        document.body.appendChild(downloadAnchorNode);
        downloadAnchorNode.click();
        downloadAnchorNode.remove();
    });

    // å·¥å…·å‡½æ•°
    function clampInt(v, min, max, fallback) {
        if (Number.isNaN(v)) return fallback;
        return Math.min(Math.max(Math.round(v), min), max);
    }
    function clampNum(v, min, max, fallback) {
        if (Number.isNaN(v)) return fallback;
        return Math.min(Math.max(v, min), max);
    }

    // åˆå§‹ï¼šé™åˆ¶é»˜è®¤å‚æ•°è¾“å…¥
    [defFloorsEl, defFloorHeightEl, defUnitsEl].forEach(el => {
        el.addEventListener('change', () => {
            defFloorsEl.value = clampInt(parseInt(defFloorsEl.value), 1, 300, 18);
            defFloorHeightEl.value = clampNum(parseFloat(defFloorHeightEl.value), 1, 20, 3);
            defUnitsEl.value = clampInt(parseInt(defUnitsEl.value), 1, 50, 2);
        });
    });

    // å¤–å±‚åˆ†éš”æ¡ï¼ˆè°ƒæ•´æ­¥éª¤1-4åŒºåŸŸé«˜åº¦ï¼‰
    const topPane = document.getElementById('topPane');
    const bottomPane = document.getElementById('bottomPane');
    const outerResizer = document.getElementById('outerResizer');

    let outerResize = { active: false, startY: 0, startHeight: 0 };

    function setTopPaneHeight(px) {
        const sidebar = document.getElementById('sidebar');
        const minPx = 160; // è‡³å°‘èƒ½çœ‹è§å‡ ä¸ªæ§ä»¶
        const maxPx = Math.max(160, sidebar.clientHeight - 240); // ä¿è¯ä¸‹åŠéƒ¨åˆ†æœ‰ç©ºé—´
        const clamped = Math.max(minPx, Math.min(px, maxPx));
        topPane.style.height = clamped + 'px';
        // å¯èƒ½éœ€è¦åŒæ­¥é™åˆ¶è¡¨æ ¼é«˜åº¦ï¼ˆå½“ä¸ŠåŠéƒ¨åˆ†å˜å¤§æ—¶ï¼Œä¸‹åŠéƒ¨åˆ†å˜å°ï¼‰
        clampTableHeightToBottomPane();
    }

    outerResizer.addEventListener('mousedown', (e) => {
        e.preventDefault();
        outerResize.active = true;
        outerResize.startY = e.clientY;
        outerResize.startHeight = topPane.getBoundingClientRect().height;
        outerResizer.classList.add('active');
        document.body.style.cursor = 'row-resize';
    });

    window.addEventListener('mousemove', (e) => {
        if (!outerResize.active) return;
        const delta = e.clientY - outerResize.startY;
        setTopPaneHeight(outerResize.startHeight + delta);
    });

    window.addEventListener('mouseup', () => {
        if (outerResize.active) {
            outerResize.active = false;
            outerResizer.classList.remove('active');
            document.body.style.cursor = '';
        }
        if (innerResize.active) {
            innerResize.active = false;
            tableResizer.classList.remove('active');
            document.body.style.cursor = '';
        }
    });

    // å†…å±‚åˆ†éš”æ¡ï¼ˆè°ƒæ•´è¡¨æ ¼é«˜åº¦ï¼‰
    const tableWrapper = document.getElementById('table-wrapper');
    const tableResizer = document.getElementById('tableResizer');
    let innerResize = { active: false, startY: 0, startHeight: 0 };

    function tableMaxHeight() {
        // ç»™è¡¨å¤´/æŒ‰é’®/å†…è¾¹è·ç•™å‡ºç©ºé—´
        const reserve = 130;
        return Math.max(120, bottomPane.clientHeight - reserve);
    }

    function setTableHeight(px) {
        const clamped = Math.max(120, Math.min(px, tableMaxHeight()));
        tableWrapper.style.height = clamped + 'px';
    }

    function clampTableHeightToBottomPane() {
        const maxH = tableMaxHeight();
        const curH = tableWrapper.getBoundingClientRect().height;
        if (curH > maxH) {
            tableWrapper.style.height = maxH + 'px';
        }
    }

    tableResizer.addEventListener('mousedown', (e) => {
        e.preventDefault();
        innerResize.active = true;
        innerResize.startY = e.clientY;
        innerResize.startHeight = tableWrapper.getBoundingClientRect().height;
        tableResizer.classList.add('active');
        document.body.style.cursor = 'row-resize';
    });

    window.addEventListener('mousemove', (e) => {
        if (!innerResize.active) return;
        const delta = e.clientY - innerResize.startY;
        setTableHeight(innerResize.startHeight + delta);
    });

    // åˆæ¬¡è®¾ç½®é«˜åº¦ï¼ˆæ ¹æ® CSS å˜é‡åˆå§‹å€¼ï¼‰
    window.addEventListener('load', () => {
        const initialTop = Math.max(160, Math.min(window.innerHeight * 0.6, window.innerHeight * 0.40));
        topPane.style.height = initialTop + 'px';

        const initialTable = Math.max(120, Math.min(window.innerHeight * 0.7, window.innerHeight * 0.32));
        tableWrapper.style.height = initialTable + 'px';

        clampTableHeightToBottomPane();
    });

    // çª—å£å˜åŒ–æ—¶ï¼Œç¡®ä¿é«˜åº¦æœ‰æ•ˆ
    window.addEventListener('resize', () => {
        clampTableHeightToBottomPane();
    });
</script>
</body>
</html>